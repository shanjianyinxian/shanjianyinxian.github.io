<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程小罗的虎啸山庄</title>
  
  
  <link href="https://shanjianyinxian.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://shanjianyinxian.gitee.io/"/>
  <updated>2021-07-13T15:00:43.087Z</updated>
  <id>https://shanjianyinxian.gitee.io/</id>
  
  <author>
    <name>程小罗</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ELK日志系统的麻烦日常</title>
    <link href="https://shanjianyinxian.gitee.io/2021/07/13/ELK%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%BA%BB%E7%83%A6%E6%97%A5%E5%B8%B8/"/>
    <id>https://shanjianyinxian.gitee.io/2021/07/13/ELK%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%BA%BB%E7%83%A6%E6%97%A5%E5%B8%B8/</id>
    <published>2021-07-13T13:19:50.000Z</published>
    <updated>2021-07-13T15:00:43.087Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：ELK+filebeat 7.1.1</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>不定期更新，记录平时遇到的ELK+filebeat日志系统的坑。</p><hr><ul><li><p><strong>请对logstash和elasticsearch使用集群</strong><br>单机部署的就没有命久的，总是启停很麻烦。logstash为多实例，es为集群。尽量保证一台机器部署一个logstash或者es实例。这两个都是吃内存大户。<br>如果成本有所不足可以考虑es的热温冷架构。热节点使用ssd提升io，稳冷节点使用普通硬盘即可。</p></li><li><p><strong>filebeat传输logstash启动负载均衡</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim filebeat.yml</span></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">%logstash_url_list%</span></span><br><span class="line">  <span class="attr">loadbalance:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>loadbalance</code>为false则会变成类似主备的方式向logstash输送数据。filebeat会自动检测想要传输数据的logstash是否忙，如果忙则传输到另一个logstash实例。</p></li><li><p><strong>filebeat支持使用环境变量，结果环境变量是中文，linux系统编码是GBK，elk系统默认编码utf-8，最后传到es里面全是乱码</strong><br>终极解决办法：使用UTF-8编码方式写一个shell脚本。在脚本里面export需要的中文环境变量。然后脚本内部执行filebeat。<br>别修改linux系统的编码了，修改完同机其他服务程序崩了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> encoding: utf-8</span></span><br><span class="line">export A=&quot;哈哈&quot;</span><br><span class="line">nohup $PWD/filebeat -e -c filebeat.yml &amp;</span><br></pre></td></tr></table></figure><p>如果filebeat的配置文件中使用了{A}这个环境变量，则此时编码正确。</p></li><li><p><strong>如上，elk+filebeat启动时候最好加上绝对路径启动</strong><br>使用<code>ps -ef |grep ***</code>查询elk+filebeat的进程时候，如果使用相对路径启动组件，则结果返回的也是相对路径。对于运维来说比较难管理，只有部署的人自己知道这个组件放在了哪里。</p></li><li><p><strong>能用shell脚本控制就用脚本控制</strong><br>shell脚本不只是说解决中文环境变量问题，可以使用脚本切换使用的jdk版本（logstash和es需要），也可以不用每次手动输入运行指令，也可以运行多个指令完成更为复杂的控制。能用一行命令解决的问题就别重复写多次。</p></li><li><p><strong>生产环境千万别用如下这个插件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cat one-pipeline.conf</span><br><span class="line">output&#123;</span><br><span class="line">stdout &#123;</span><br><span class="line">    codec &#x3D;&gt; rubydebug</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试过不加这个，让我的性能提升了3倍。该语句会输出每条被处理的数据到控制台，会大幅降低logstash处理效率，并且该组件有未知bug导致logstash停止工作（具体在查看logstash日志时候会提示ruby output的未知错误并且提示用户重启logstash）。为了生产环境的稳定，别加入这种用于调试的输出插件。</p></li><li><p><strong>有logstash和es的jvm调优意识</strong><br>es和logstash为java程序，jvm默认1g内存占用，这完全不够用。按照官方建议不要超过32G，不要超过内存的50%。-Xms -Xmx 两个参数设置为相同</p></li><li><p><strong>请使用索引模板，设置生命周期管理，不然磁盘很容易满</strong><br>生命周期管理天然适配热温冷架构，生命周期管理一般与索引模板相结合使用，使用kibana设置索引模板，然后在kibana内就可以可视化自定义生命周期管理策略，并且绑定到索引模板上。<br>对于日志系统来说，越久远的日志越无价值。因此使用生命周期管理可以及时删除过期日志数据。<br>模板文件规定了分片，副本，字段映射与格式，生命周期，索引别名等配置。对管理es索引很有用，因此请在导入数据之前先规定好索引模板。</p></li><li><p><strong>如果logstash要处理不同日志格式的数据，建议还是使用pipeline吧</strong><br>对于多日志格式的解析，有一种解决办法是在filebeat中对不同的日志格式创建不同的tag，并且在logstash的filter组件中使用if条件判断是哪一种日志格式。这是一种单管道的处理方式，这种方式会导致logstash.conf处理管道配置文件变得繁琐并且可读性极差。万一管道出错停止运行，两种格式都无法解析。<br>可以在pipelines.yml中配置多个管道，对于不同格式的日志文件各占据一个管道。唯一需要注意的是每个管道conf文件中的input beat端口需要不同。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">pipeline.id:</span> <span class="string">template1</span></span><br><span class="line">  <span class="attr">path.config:</span> <span class="string">&quot;%config_pipeline_path%/logstash-template1.conf&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pipeline.id:</span> <span class="string">template2</span></span><br><span class="line">  <span class="attr">path.config:</span> <span class="string">&quot;%config_pipeline_path%/logstash-template2.conf&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>logstash连接达梦数据库的jdbc组件写法，是模仿Oracle的</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">        ...</span><br><span class="line">        jdbc_driver_class &#x3D;&gt; &quot;Java::dm.jdbc.driver.DmDriver&quot; &#x2F;&#x2F;这里一定要加上Java::，mysql则不用加</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>达梦一点文档没有，这我折腾了好久。。。后来无意中看到达梦是模仿Oracle写的，加上就发现好使了。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：ELK+filebeat 7.1.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;不定期更新，记录平时遇到的E</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ELK" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/ELK/"/>
    
    
    <category term="ELK" scheme="https://shanjianyinxian.gitee.io/tags/ELK/"/>
    
    <category term="elasticsearch" scheme="https://shanjianyinxian.gitee.io/tags/elasticsearch/"/>
    
    <category term="kibana" scheme="https://shanjianyinxian.gitee.io/tags/kibana/"/>
    
    <category term="logstash" scheme="https://shanjianyinxian.gitee.io/tags/logstash/"/>
    
    <category term="filebeat" scheme="https://shanjianyinxian.gitee.io/tags/filebeat/"/>
    
  </entry>
  
  <entry>
    <title>踩坑日记-python的浮点数比对</title>
    <link href="https://shanjianyinxian.gitee.io/2021/07/11/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0-python%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E5%AF%B9/"/>
    <id>https://shanjianyinxian.gitee.io/2021/07/11/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0-python%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E5%AF%B9/</id>
    <published>2021-07-10T16:01:38.000Z</published>
    <updated>2021-07-10T16:18:39.527Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：python3</p></blockquote><p>之前写算法的时候遇到个非常细小但是致命的错误，当时使用异常检测算法，遇到了检测出的异常非常离谱。整个算法似乎不生效。后来debug一点一点排查原因，发现了原来算法逻辑中有对浮点数进行相等判断，当时直接使用了 “==”。这个地方出了大问题。</p><p>对于浮点数的判断，计算机中对于浮点数无法在数学上进行解析完全相等。计算机只能尽可能的数值模拟一个值。即使对于类似于3.0这样的在我们看来是一个整数的值，对于计算机来说，他可能内部表达为3.000000000001。因此对于3 和 3.000000000001进行 “==” 判断，返回的一定是false。</p><p>因此对于python的浮点数判断，只能使用近似。这就需要使用到 math.isclose() 函数</p><hr><h4 id="math-isclose-a-b-abs-tol-rel-tol"><a href="#math-isclose-a-b-abs-tol-rel-tol" class="headerlink" title="math.isclose(a,b,abs_tol,rel_tol)"></a><strong>math.isclose(a,b,abs_tol,rel_tol)</strong></h4><ul><li>a：必要， 检查紧密度的第一个值</li><li>b：必要， 检查紧密度的第二个值</li><li>rel_tol： 可选。 相对公差。 它是值a和b之间的最大允许差。 默认值为1e-09 </li><li>abs_tol： 可选。最小绝对公差。它用于比较接近0的值。该值必须至少为0 </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isclose(<span class="number">0.001</span>,<span class="number">0</span>,abs_tol=<span class="number">0.1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isclose(<span class="number">0.001</span>,<span class="number">0</span>,abs_tol=<span class="number">0.001</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isclose(<span class="number">0.001</span>,<span class="number">0</span>,abs_tol=<span class="number">0.0001</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isclose(<span class="number">8.00001</span>,<span class="number">7.99999</span>,rel_tol=<span class="number">0.0001</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isclose(<span class="number">8.00001</span>,<span class="number">7.99999</span>,rel_tol=<span class="number">0.00001</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isclose(<span class="number">8.00001</span>,<span class="number">7.99999</span>,rel_tol=<span class="number">0.000001</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>一般来说，我使用<code>rel_tol</code>来判断两个浮点数是否接近。使用<code>abs_tol</code> 判断一个浮点数与0是否接近。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：python3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前写算法的时候遇到个非常细小但是致命的错误，当时使用异常检测算法，遇到了检测出的异常非常离谱。整个算法似乎不生效。后来debug一点一点排查原因，发现了原来算法逻辑中有对浮点数进行相</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="python" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/python/"/>
    
    
    <category term="python" scheme="https://shanjianyinxian.gitee.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>java小知识</title>
    <link href="https://shanjianyinxian.gitee.io/2021/07/08/java%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>https://shanjianyinxian.gitee.io/2021/07/08/java%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2021-07-07T16:31:23.000Z</published>
    <updated>2021-07-10T17:00:25.887Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编程语言：java</p></blockquote><p>不定期更新，记录自己学习的java小知识。</p><hr><ol><li><p>Java放置在堆中的变量有默认值，如对象数据，类的属性等；而栈中的（局部变量），方法区中的（static属性等）变量必须要有初始值，无默认值。</p></li><li><p>Java 方法，属性，构造器，内部类的权限修饰符：public，缺省，protected，public；类修饰符：public，缺省<br><img src="/2021/07/08/java%E5%B0%8F%E7%9F%A5%E8%AF%86/01.png"></p></li><li><p>用Arrays的copyOf方法拷贝原数组内容，并设置新的长度。ArrayList扩容需要做一次数组拷贝，如果是反复扩容，肯定会对程序的运行效率产生影响。所以在初始化ArrayList的时候，尽量设置初始化容量，避免其扩容。   </p></li><li><p>java继承时，父类中的private属性和方法都会被继承，但是因为封装的原因不可使用对象调用。即 类内this. 与类外对象object. 方式调用都不行。   </p></li><li><p>Java重写（覆盖）方法的时候，子类方法权限不小于父类方法权限。   </p></li><li><p>java属性不会出现覆盖，如果子类父类中出现同名的属性，则实际上有了两个属性，需要用this和super区分。默认调用子类自己的。   </p></li><li><p>java多态，编译看左边父类，运行看右边子类。对于属性，只能使用父类属性。对于方法，只能使用父类中定义的方法，但是执行的是子类中重写的方法，这被称为虚拟方法调用。多态是运行时行为，只有在执行时才知道调用的是哪种子类的重写方法。   </p></li><li><p>object类中equals()方法与“==”运算符功能相同，因此不能用来比较两个对象的内容是否相等。String，Date，file，包装类等中的equals()方法进行了重写，用来比较两个字符串内容是否相同。因此若要比较两个对象是否相等，需要重写equals方法。一般可以用IDE自动生成。<br><img src="/2021/07/08/java%E5%B0%8F%E7%9F%A5%E8%AF%86/02.png"></p></li><li><p>java中的内存地址都是虚拟的内存地址，是hashcode计算得到的一个值。在操作系统之上，设置了一个JVM。   </p></li><li><p>为每一种基本数据类型定义的相应的引用类型为包装类（封装类）。主要用于针对基本数据类型的面向对象化。可以对基本数据类型进行封装，并且增加新的功能。   </p></li><li><p>包装类可以自动装箱，即Integer i = 10这种写法是可以的，而不需要new构造。同样的也可以自动拆箱：int j = i 这种是可以的。   </p></li><li><p>String.valueof(基本数据类型，包装类)得到String<br>包装类.parseXXX(String)得到基本数据类型,如Integer.parseInt(String)。</p></li><li><p>三元运算符会提升数据类型，如下图所示：<br><img src="/2021/07/08/java%E5%B0%8F%E7%9F%A5%E8%AF%86/03.png"></p></li><li><p>Java中-128到127小数存储，因此包装类包装小整数，并且使用自动装箱方式，也会被认为是同一个对象，类似于python中的小整数池[-5,256]。实现方法都是内建类。<br><img src="/2021/07/08/java%E5%B0%8F%E7%9F%A5%E8%AF%86/04.png"></p></li><li><p>单例模式：<br>饿汉式：对象加载时间长（坏）线程安全（好）<br>懒汉式：延迟对象的创建（好）如果不能保证原子性操作（加锁）则线程不安全（不好）</p></li><li><p>  单例模式需要私有化构造器，如果使用私有的构造器，当你尝试去new的时候编译器就会马上阻止你当前的操作。   </p></li><li><p>  接口里面没有构造器，因此不能实例化。所以类必须实现接口中的方法。如果没有实现所有的抽象方法，则该类为抽象类。如果全部实现则可以实例化该类。   </p></li><li><p>  模板设计模式本质是抽象类的使用，在模板类中有模板方法，模板方法定义了程序执行的流程，调用了模板类中的其他方法，有些方法为抽象方法，这些方法被称为钩子方法，通过继承模板类的子类实现钩子方法，以实现不同的功能，体现出多态。   </p></li><li><p>接口的继承问题：AA，BB中都有抽象方法method1，CC继承了AA和BB，class1实现了CC，对于method1因为都是抽象方法，都没有具体实现，因此并不会存在python多继承中父类同名方法的继承顺序问题，毕竟AA，BB接口中的两个method1都没有具体实现，接口只是增加功能。<br><img src="/2021/07/08/java%E5%B0%8F%E7%9F%A5%E8%AF%86/05.png"></p></li><li><p>接口也可以跟父类一样，做向上继承，如初始化或者在方法参数中声明一个接口，然后具体传入的是一个接口的实现。   </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.java;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">computer.transferInfo(<span class="keyword">new</span> Printer());</span><br><span class="line">computer.transferInfo(<span class="keyword">new</span> Flash());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferInfo</span><span class="params">(USB usb)</span> </span>&#123;</span><br><span class="line">usb.start();</span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开始工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘开始工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果子类或实现类继承的父类和实现的接口中声明了同名同参数的方法，则子类在没有重写方法的情况下，默认调用的是<strong>父类</strong>中的方法。<strong>（类优先原则）</strong></p></li><li><p>实现类实现了多个接口，多个接口中定义了同名同参数的默认方法，则在实现类没有重写的情况下，则会报错，这种情况称为<strong>接口冲突，</strong>想要解决只能重写，或者定义不重名的接口默认方法。</p></li><li><p>如何调用接口中和父类中的同名方法与属性、常量：一般来说接口中的全局常量命名全大写，因此符合命名规范的情况下，不会引起冲突。</p></li><li><p>MyThread继承Thread类实现多线程，重写run方法（用来实现自己的程序逻辑），MyThread实例化对象myThread后调用start()方法，该方法创建新的线程，并且调用run()方法。不能直接调用run()方法，因为这意味着没有创建新的线程，因此也就不是多线程编程了。</p></li><li><p>一个myThread实例化多线程对象只能调用start()方法一次，如果想再开一个线程，则需要新建一个多线程对象。线程优先级高不代表线程一定先执行，只是概率上调度优先被调度。</p></li><li><p>多个线程如果有共享数据，则使用runnable接口方式天然可以保证一个runnable方式被多个thread共享。并且可以解决类的单继承局限性。</p></li><li><p>任何对象可以充当锁，要求每个线程必须共用同一把锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.exer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 线程不安全性的例子，任何对象都可以充当锁，但是每个线程必须共用一把 优点：解决线程不安全 缺点：同步的代码或者方法，实际上为单线程。</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSecureDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Count count = <span class="keyword">new</span> Count();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(count);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(count);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Object mutex = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// synchronized (this) &#123; 这种写法也行，此时不需要新建一把锁。</span></span><br><span class="line"><span class="comment">// 因为window w1对象是唯一的。不管何种写法只需要保证锁唯一即可。</span></span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>  同步代码块方式同步：类也是对象，并且只会加载一次，因此是唯一的，可以作为线程同步的锁。   </p></li><li><p>为何反射机制中，getDeclaredMethod(name, <strong>Class… parameterTypes</strong>) 需要填写参数类型？因为系统通过函数名，参数类型与参数类型顺序唯一确定一个函数，如果有函数重载发生，则可以通过参数类型区分。</p></li><li><p>字符串存于方法区常量池中，JVM1.7之前在永久代，1.7在堆中，1.7后在元空间（永久代被取消，成为元空间）</p></li><li><p>链式调用方法链的原理：一个对象的方法返回值为对象本身即可。object.method()返回object，则可以继续后面跟着.method()</p></li><li><p>sleep()和wait()都会阻塞，但是wait()会释放锁。wait()和notify()/notifyAll()用于线程间通信，必须在同步方法和代码块中。notify()唤醒一个优先级高的线程，notifyAll()唤醒所有。</p></li><li><p>wait()和notify()/notifyAll()的调用者必须是所在同步方法和代码块对应的锁。因为任何对象都可以当锁，因此这三种方法定义在了Object类中。</p></li><li><p>子程序throw 异常，主程序try/catch子程序的异常。如果子程序之间有顺序执行关系，若第一个子程序内部try/catch，则在处理完子程序异常之后，主程序仍然不受影响的继续执行第二个子程序，这样是没有意义的。因此所有的异常由主程序判断如何处理。</p></li><li><p>set添加元素时，保证添加的元素按照equals()方法判断，不能返回true。即相同元素只能添加一个。</p></li><li><p>set删除元素时，remove方法根据hashcode进行删除，如果hashcode找得到则使用equal()方法判断是不是要删除的数据，如果集合内的元素发生了修改，则无法再次根据原来的引用进行删除。<br><img src="/2021/07/08/java%E5%B0%8F%E7%9F%A5%E8%AF%86/06.png"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;编程语言：java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不定期更新，记录自己学习的java小知识。&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java放置在堆中的变量有默认值，如对象数据，类的属性等；而栈中的（局部变量），方法区中的（stat</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="java" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/java/"/>
    
    
    <category term="java" scheme="https://shanjianyinxian.gitee.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>hexo指令执行失败问题解决</title>
    <link href="https://shanjianyinxian.gitee.io/2021/07/06/hexo%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://shanjianyinxian.gitee.io/2021/07/06/hexo%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2021-07-06T08:45:55.000Z</published>
    <updated>2021-07-06T09:04:28.547Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：hexo，hexo主题（bufferfly）</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>今天重新部署hexo博客，出现了如下的问题，所有得hexo指令都报如下错误：</p><p><img src="/2021/07/06/hexo%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/hexo%E6%8A%A5%E9%94%99_%E9%97%AE%E9%A2%98.png" alt="hexo报错_问题"></p><hr><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>经过排查，原因是node版本太低。之前使用了nvm安装了多版本的node，当前切换到了低版本的node。这里切换回高版本即可解决问题。</p><img src="/2021/07/06/hexo%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/hexo报错_解决.png" alt="hexo报错_解决" style="zoom: 80%;">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：hexo，hexo主题（bufferfly）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;今天重新部署hexo</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="hexo" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://shanjianyinxian.gitee.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机Ubuntu 18.04.2 LTS设置固定ip过程</title>
    <link href="https://shanjianyinxian.gitee.io/2021/07/04/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu-18-04-2-LTS%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip%E8%BF%87%E7%A8%8B/"/>
    <id>https://shanjianyinxian.gitee.io/2021/07/04/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu-18-04-2-LTS%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip%E8%BF%87%E7%A8%8B/</id>
    <published>2021-07-04T15:25:50.000Z</published>
    <updated>2021-07-10T15:41:12.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统：Ubuntu 18.04.2 LTS</p><p>虚拟机：VMware 12</p></blockquote><p>设置多个虚拟机组件集群的时候，需要配置各个虚拟机有着不同的ip地址。因此这里简单介绍一下如何配置虚拟机ip。</p><hr><ul><li><p><strong>设置虚拟机网络为nat模式</strong><br><img src="/2021/07/04/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu-18-04-2-LTS%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip%E8%BF%87%E7%A8%8B/01.png" alt="01"></p></li><li><p><strong>打开虚拟机网络编辑器选项</strong><br><img src="/2021/07/04/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu-18-04-2-LTS%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip%E8%BF%87%E7%A8%8B/02.png" alt="02"></p></li><li><p><strong>更改设置，取消DHCP服务，设定子网ip(该服务是用来动态分配ip地址)</strong><br><img src="/2021/07/04/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu-18-04-2-LTS%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip%E8%BF%87%E7%A8%8B/03.png" alt="03"></p></li><li><p><strong>网关ip</strong><br><img src="/2021/07/04/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu-18-04-2-LTS%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip%E8%BF%87%E7%A8%8B/05.png" alt="05"></p></li><li><p><strong>sudo vim /etc/network/interfaces 修改网络配置</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/network/interfaces</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line"><span class="string">auto</span> <span class="string">lo</span></span><br><span class="line"><span class="string">iface</span> <span class="string">lo</span> <span class="string">inet</span> <span class="string">loopback</span></span><br><span class="line"></span><br><span class="line"><span class="string">auto</span> <span class="string">ens33</span> <span class="comment">#查看自己的网卡名称，可以通过ifconfig命令查询</span></span><br><span class="line"><span class="string">iface</span> <span class="string">ens33</span> <span class="string">inet</span> <span class="string">static</span> <span class="comment">#设置该网卡为静态ip</span></span><br><span class="line"><span class="string">address</span> <span class="number">192.168</span><span class="number">.73</span><span class="number">.129</span> <span class="comment">#静态IP地址设置</span></span><br><span class="line"><span class="string">netmask</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> <span class="comment">#掩码设置</span></span><br><span class="line"><span class="string">gateway</span> <span class="number">192.168</span><span class="number">.73</span><span class="number">.2</span> <span class="comment">#网关ip设置</span></span><br><span class="line"><span class="string">dns-nameservers</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> <span class="comment">#DNS服务器地址设置（解析域名，访问外网）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>若出现可以ping通DNS服务器，但是不能ping通域名，则DNS设置仍然有问题，修改/etc/systemd/resolved.conf内容</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/systemd/resolved.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  This file is part of systemd.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  systemd is free software; you can redistribute it and/or modify it</span></span><br><span class="line"><span class="comment">#  under the terms of the GNU Lesser General Public License as published by</span></span><br><span class="line"><span class="comment">#  the Free Software Foundation; either version 2.1 of the License, or</span></span><br><span class="line"><span class="comment">#  (at your option) any later version.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Entries in this file show the compile time defaults.</span></span><br><span class="line"><span class="comment"># You can change settings by editing this file.</span></span><br><span class="line"><span class="comment"># Defaults can be restored by simply deleting this file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See resolved.conf(5) for details</span></span><br><span class="line"></span><br><span class="line">[<span class="string">Resolve</span>]</span><br><span class="line"><span class="comment">#添加DNS服务器地址</span></span><br><span class="line"><span class="string">DNS=114.114.114.114</span></span><br><span class="line"><span class="string">DNS=8.8.8.8</span></span><br><span class="line"><span class="comment">#DNS=</span></span><br><span class="line"><span class="comment">#FallbackDNS=</span></span><br><span class="line"><span class="comment">#Domains=</span></span><br><span class="line"><span class="comment">#LLMNR=no</span></span><br><span class="line"><span class="comment">#MulticastDNS=no</span></span><br><span class="line"><span class="comment">#DNSSEC=no</span></span><br><span class="line"><span class="comment">#Cache=yes</span></span><br><span class="line"><span class="comment">#DNSStubListener=yes</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重启机器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统：Ubuntu 18.04.2 LTS&lt;/p&gt;
&lt;p&gt;虚拟机：VMware 12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设置多个虚拟机组件集群的时候，需要配置各个虚拟机有着不同的ip地址。因此这里简单介绍一下如何配置虚拟机ip。&lt;/p&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="linux" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/linux/"/>
    
    
    <category term="linux" scheme="https://shanjianyinxian.gitee.io/tags/linux/"/>
    
    <category term="运维" scheme="https://shanjianyinxian.gitee.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="虚拟机" scheme="https://shanjianyinxian.gitee.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>运维经验</title>
    <link href="https://shanjianyinxian.gitee.io/2021/06/18/%E8%BF%90%E7%BB%B4%E7%BB%8F%E9%AA%8C/"/>
    <id>https://shanjianyinxian.gitee.io/2021/06/18/%E8%BF%90%E7%BB%B4%E7%BB%8F%E9%AA%8C/</id>
    <published>2021-06-18T08:31:17.000Z</published>
    <updated>2021-07-10T12:45:34.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统：linux</p></blockquote><p>不定期更新，记录自己遇到的运维经验总结。</p><hr><ul><li><p>top命令 load average：三个值  分别代表 <strong>最近1分钟</strong>、<strong>最近5分钟</strong>和<strong>最近15分钟</strong>的平均负载</p><ul><li>通常，如果系统的负载值超过了2，就说明系统比较繁忙了。<br>Linux系统管理的要点在于定义究竟到什么程度才算是高负载。这个值取决于系统的硬件配置以及系统上通常运行的程序。对某个系统来说是高负载的值可能对另一系统来说就是正常值。</li><li>由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见，但如果近15分钟内的平均负载都很高，就说明系统可能有问题。</li></ul></li><li><p>du -sh * | sort -nr  该命令可以用于对文件大小的排序显示</p><ul><li>sort -n 在排序数值时非常有用</li><li>sort -r 逆序，从大到小</li><li>du -h 清楚显示</li><li>du -s 显示每个输出参数的总计，即仅显示总计,只列出最后加总的值 </li></ul></li><li><p>tar 的压缩与解压 <a href="https://www.cnblogs.com/hester/p/10449978.html">https://www.cnblogs.com/hester/p/10449978.html</a></p><ul><li>tar -zxvf filename.tgz<br>下载了开源软件之后，你会经常看到文件名以.tgz结尾(.tar.gz)。这些是gzip压缩过的tar文件可以用命令来解压。</li><li>tar -zcvf filename.tgz<br>解压</li></ul></li><li><p>cat /etc/passwd 第七列查看用户使用的shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd</span></span><br><span class="line">[...]</span><br><span class="line">moon:x:1000:1000::/home/moon:/bin/bash</span><br></pre></td></tr></table></figure></li><li><p>默认的系统shell和默认的交互shell软连接可能不同，即/etc/passwd 中的shell和/bin下sh软连接指向的shell不同，这个可能会带来某些问题。因此shell脚本首行指定shell解释器不可少</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">[<span class="type">...</span>]</span><br></pre></td></tr></table></figure></li><li><p>ps -ef很常用，-H可以更清楚的显示进程间层级关系</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[moon@myserver 002shell]$ ps -efH | grep bash</span><br><span class="line">moon       3620   3619  0 13:41 pts/0    00:00:00         -bash</span><br><span class="line">moon       5419   3620  0 14:23 pts/0    00:00:00           bash</span><br><span class="line">moon       5565   5419  0 14:29 pts/0    00:00:00             grep --color=auto bash</span><br><span class="line">root      10282  10265  0  2020 pts/0    00:00:00       /bin/bash</span><br><span class="line">root      41399  41382  0  2020 ?        00:00:00       bash run.sh</span><br><span class="line">moon     105516 105515  0 Apr17 pts/2    00:00:00     /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>echo $BASH_SUBSHELL<br>要想知道是否生成了子shell，得借助一个使用了环境变量的命令。这个命令就是echo $BASH_SUBSHELL。如果该命令返回0，就表明没有子shell。如果返回1或者其他更大的数字，就表明存在子shell。</p></li><li><p>jobs<br>除了ps命令，你也可以使用jobs命令来显示后台作业信息。jobs命令可以显示出当前运行在后台模式中的所有用户的进程（作业）。</p></li><li><p>使用后台模式，进程列表和协程，利用子shell组合任务并且执行，可以让shell的I/O不受制于终端</p></li><li><p>/etc/group查看组列表时，有些组并没有列出用户，这并不是说这些组没有成员。当一个用户在/etc/passwd文件中指定某个组作为默认组时，用户账户不会作为该组成员再出现在/etc/group文件中。</p></li><li><p>记住，bash shell只能处理整数。如果你只是要通过echo语句来显示这个结果，那没问题。但是，在基于数字的函数中就不行了，例如我们的数值测试条件。最后一行就说明我们不能在test命令中使用浮点值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat floating_point_test.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using floating point numbers <span class="keyword">in</span> <span class="built_in">test</span> evaluations</span></span><br><span class="line"><span class="meta">　 #</span></span><br><span class="line">value1=5.555</span><br><span class="line"><span class="meta">　 #</span></span><br><span class="line">echo &quot;The test value is $value1&quot;</span><br><span class="line"><span class="meta">　 #</span></span><br><span class="line">if [ $value1 -gt 5 ]</span><br><span class="line">　 then</span><br><span class="line">　　echo &quot;The test value $value1 is greater than 5&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">　 #</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./floating_point_test.sh</span></span><br><span class="line">The test value is 5.555</span><br><span class="line">./floating_point_test.sh: line 8:</span><br><span class="line">[: 5.555: integer expression expected</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure></li><li><p>shell 脚本中 if 条件比较字符串时，＞ 和 ＜ 需要转义符号，不然会被认成重定向</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ $val1 \&gt; $val2 ]</span><br><span class="line">then</span><br><span class="line">[...]</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>shell脚本在test比较测试中，大写字母被认为是小于小写字母的。但sort命令恰好相反。当你将同样的字符串放进文件中并用sort命令排序时，小写字母会先出现。这是由各个命令使用的排序技术不同造成的。</p></li><li><p>空的和未初始化的变量会对shell脚本测试造成灾难性的影响。如果不是很确定一个变量的内容，最好在将其用于数值或字符串比较之前先通过-n或-z来测试一下变量是否含有值。<br>-n和-z可以检查一个变量是否含有数据。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -n $val1 ]</span><br><span class="line">if [ -z $val2 ]</span><br><span class="line">if [ -z $val3 ]</span><br></pre></td></tr></table></figure></li><li><p>一般来说，可以使用，模板文件配合shell中的sed命令对源文件进行替换，进而完成许多定制的功能。比如：对一个python文件进行修改。可以先定义一个python模板，然后每次复制python文件的模板，使用sed命令替换被复制的模板。比如：<br>这是python文件模板</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#demo-template.py</span></span><br><span class="line">kwargs= &#123; <span class="string">&#x27;parm_a&#x27;</span> : %parm_a%, <span class="string">&#x27;parm_b&#x27;</span>: %parm_b%, <span class="string">&#x27;parm_c&#x27;</span>: %parm_c%&#125;</span><br></pre></td></tr></table></figure><p>这是shell指令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp demo-template.py demo.py</span><br><span class="line">sed -i &quot;/s/%parm_a%/1/g&quot; demo.py</span><br><span class="line">sed -i &quot;/s/%parm_b%/2/g&quot; demo.py</span><br><span class="line">sed -i &quot;/s/%parm_c%/3/g&quot; demo.py</span><br></pre></td></tr></table></figure><p>这是替换之后的文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#demo.py</span></span><br><span class="line">kwargs= &#123; <span class="string">&#x27;parm_a&#x27;</span> : <span class="number">1</span>, <span class="string">&#x27;parm_b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;parm_c&#x27;</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以从外界定义一个配置文件或者自定义一个主控程序根据需要动态的修改文本内容，达到不同的效果。</p></li><li><p>sed命令的分隔符 反斜杠 “/” 经常出问题（比如文件内容中含有路径这样带有反斜杠的文本）。建议换成 “#”</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统：linux&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不定期更新，记录自己遇到的运维经验总结。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;top命令 load average：三个值  分别代表 &lt;strong&gt;最近1分钟&lt;/strong</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="linux" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/linux/"/>
    
    
    <category term="linux" scheme="https://shanjianyinxian.gitee.io/tags/linux/"/>
    
    <category term="运维" scheme="https://shanjianyinxian.gitee.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>好久不见</title>
    <link href="https://shanjianyinxian.gitee.io/2021/06/06/%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/"/>
    <id>https://shanjianyinxian.gitee.io/2021/06/06/%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/</id>
    <published>2021-06-06T06:59:13.000Z</published>
    <updated>2021-07-10T12:57:51.302Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新自己的博客了，过完年之后工作十分忙碌，比赛，项目，运维等等一系列事情需要去做。当时觉得一直不更新也不好，于是中途关闭了自己的博客。虽然博客关了，但这段时间的工作也一直保持学习。工作的过程也会遇到很多问题， 每次问题的解决对个人来说也是一次成长。这次重新开通博客也是希望能和更多的人交流。</p><p>最后，最近gitee没法开启个人博客。因此暂时只保留github的页面。之后也会同步gitee的个人博客。主要是github可能有时候访问较慢，有了gitee之后会好很多。</p><p>以上。o(<em>￣▽￣</em>)ブ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没有更新自己的博客了，过完年之后工作十分忙碌，比赛，项目，运维等等一系列事情需要去做。当时觉得一直不更新也不好，于是中途关闭了自己的博客。虽然博客关了，但这段时间的工作也一直保持学习。工作的过程也会遇到很多问题， 每次问题的解决对个人来说也是一次成长。这次重新开通博客也</summary>
      
    
    
    
    <category term="生活" scheme="https://shanjianyinxian.gitee.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="随笔" scheme="https://shanjianyinxian.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>java反射读取类的私有属性并且读取实例属性值</title>
    <link href="https://shanjianyinxian.gitee.io/2021/03/18/java%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%B9%B6%E4%B8%94%E8%AF%BB%E5%8F%96%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%80%BC/"/>
    <id>https://shanjianyinxian.gitee.io/2021/03/18/java%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%B9%B6%E4%B8%94%E8%AF%BB%E5%8F%96%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%80%BC/</id>
    <published>2021-03-18T12:22:33.000Z</published>
    <updated>2021-07-10T09:40:55.500Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：java8</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>今天对自己写的代码分析，发现了很多不合适的地方，其中就有原先设计的bean不合理问题导致的后期需要重新侵入式的修改源代码，因此反射显得十分重要。</p><hr><p>反射可以用于使用bean匹配数据时候，当bean本身发生变化的时候，如果不使用反射，则需要修改程序中的原始代码，修改bean的getter才能获取到新的数据。如果使用反射则不需要知道bean中具体目前有哪些属性，直接可以获取到属性列表，然后根据属性列表获得bean对应实例的值。只需要修改bean即可，而不需要修改调用bean初的其他逻辑代码。</p><p>假设有个Person类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="comment">//private String city; //假设增加了一个新的属性city</span></span><br><span class="line"><span class="comment">// 省略get，set，有参空参构造，toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用反射，如果为Person增加了一个新的属性，则需要修改调用逻辑的源代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person a = <span class="keyword">new</span> Person(<span class="string">&quot;pc&quot;</span>,<span class="number">26</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里需要手动输入Person的私有属性名称，并且如果Person修改了属性，则这里也需要手动修改</span></span><br><span class="line">    List&lt;String&gt; fieldsNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    fieldsNames.add(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    fieldsNames.add(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    fieldsNames.add(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">    <span class="comment">//fieldsNames.add(&quot;city&quot;);</span></span><br><span class="line">    System.out.println(String.join(<span class="string">&quot;,&quot;</span>,fieldsNames));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里需要手动调用Person的私有属性getter方法，并且如果Person修改了属性，则这里也需要手动修改</span></span><br><span class="line">    List&lt;String&gt; fieldsValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    fieldsValues.add(a.getName());</span><br><span class="line">    fieldsValues.add(a.getAge());</span><br><span class="line">    fieldsValues.add(a.getGender());</span><br><span class="line">    <span class="comment">//fieldsValues.add(a.getCity());</span></span><br><span class="line">    System.out.println(String.join(<span class="string">&quot;,&quot;</span>,fieldsValues));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在使用反射读取Person类的私有属性名称，并且读取实例的私有属性。如果修改了Person类属性，可以看到这段代码不需要做任何修改。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    Person a = <span class="keyword">new</span> Person(<span class="string">&quot;pc&quot;</span>,<span class="number">26</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1</span></span><br><span class="line">    <span class="comment">//Class clazz = a.getClass();</span></span><br><span class="line">    <span class="comment">//Field[] fields = clazz.getDeclaredFields();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式2</span></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取类私有属性名称</span></span><br><span class="line">    List&lt;String&gt; fieldsNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Field field: fields)&#123;</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);<span class="comment">//对于私有属性必须要将访问权限打开</span></span><br><span class="line">        fieldsNames.add(field.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(String.join(<span class="string">&quot;,&quot;</span>,fieldsNames));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取类实例的属性值</span></span><br><span class="line">    List&lt;String&gt; fieldsValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Field field: fields)&#123;</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);<span class="comment">//对于私有属性必须要将访问权限打开</span></span><br><span class="line">        fieldsValues.add(field.get(a).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(String.join(<span class="string">&quot;,&quot;</span>,fieldsValues));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：java8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;今天对自己写的代码分析，发现了很多不合适的地方，其中就</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="java" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/java/"/>
    
    
    <category term="java" scheme="https://shanjianyinxian.gitee.io/tags/java/"/>
    
    <category term="反射" scheme="https://shanjianyinxian.gitee.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>java中String和byte[]中文转换的问题</title>
    <link href="https://shanjianyinxian.gitee.io/2021/03/10/java%E4%B8%ADString%E5%92%8Cbyte-%E4%B8%AD%E6%96%87%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://shanjianyinxian.gitee.io/2021/03/10/java%E4%B8%ADString%E5%92%8Cbyte-%E4%B8%AD%E6%96%87%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-10T09:23:01.000Z</published>
    <updated>2021-07-10T09:40:52.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：java8</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>今天在java的二进制byte和string类型的编解码中遇到了阻碍，因此仔细研究了一下相关的编解码问题。</p><hr><p>本文介绍了java中 byte[] 和 String 的相互转换。</p><p>通过String的getBytes()方法是可以得到一个字符串的字节数组，但特别要注意的是，getBytes()方法将返回该操作系统默认的编码格式的字节数组。 </p><ul><li><p>string转byte[] 无中文</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strHello = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bHello = strHello.getBytes();</span><br></pre></td></tr></table></figure></li><li><p>byte[]转string 无中文</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strHello = <span class="keyword">new</span> String(bHello);</span><br></pre></td></tr></table></figure></li><li><p>string转byte[] 有中文</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strChinese = <span class="string">&quot;大吉大利&quot;</span>；</span><br><span class="line"><span class="keyword">byte</span>[] bChinese_gbk = strChinese.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">//GBK编码格式</span></span><br><span class="line"><span class="keyword">byte</span>[] bChinese_utf8 = strChinese.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// UFT-8编码格式</span></span><br><span class="line"><span class="keyword">byte</span>[] bChinese_iso88591 = strChinese.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>byte[]转string 有中文</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strChinese_gbk = <span class="keyword">new</span> String(bChinese_gbk,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">String strChinese_utf8 = <span class="keyword">new</span> String(bChinese_utf8,<span class="string">&quot;UTF-8&quot;</span>); </span><br><span class="line">String strChinese_iso88591 = <span class="keyword">new</span> String(bChinese_iso88591,<span class="string">&quot;ISO8859-1&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;ISO8859-1&quot;编码中无中文字符，因此strChinese_iso88591无法还原得到中文</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：java8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;今天在java的二进制byte和string类型的编解</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="java" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/java/"/>
    
    
    <category term="java" scheme="https://shanjianyinxian.gitee.io/tags/java/"/>
    
    <category term="编解码" scheme="https://shanjianyinxian.gitee.io/tags/%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql-mysql5.5用户无需密码即可登录问题</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/30/mysql-mysql5-5%E7%94%A8%E6%88%B7%E6%97%A0%E9%9C%80%E5%AF%86%E7%A0%81%E5%8D%B3%E5%8F%AF%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/30/mysql-mysql5-5%E7%94%A8%E6%88%B7%E6%97%A0%E9%9C%80%E5%AF%86%E7%A0%81%E5%8D%B3%E5%8F%AF%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-30T14:49:43.000Z</published>
    <updated>2020-12-02T02:53:47.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：mysql5.5<br>操作系统：centos7</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>今天在Linux上安装了mysql5.5，在创建了用户之后也正常设置了密码。但是登录的时候输入密码无法登录，但是不输入密码可以登录。</p><hr><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用root用户登录mysql，查看user表。</p><p>主要问题在于user表内含有账号和密码都为空的项。将其删除即可</p><p><img src="/2020/11/30/mysql-mysql5-5%E7%94%A8%E6%88%B7%E6%97%A0%E9%9C%80%E5%AF%86%E7%A0%81%E5%8D%B3%E5%8F%AF%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/1.jpg" alt="解决方案"></p><p>最后如果需要客户端远程访问，如Navicat，则需要以下命令</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;你的用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&quot;你的密码&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：mysql5.5&lt;br&gt;操作系统：centos7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;今天在Linux</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="mysql" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/mysql/"/>
    
    
    <category term="mysql" scheme="https://shanjianyinxian.gitee.io/tags/mysql/"/>
    
    <category term="数据库" scheme="https://shanjianyinxian.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ELK-安装es集群</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/23/ELK-%E5%AE%89%E8%A3%85es%E9%9B%86%E7%BE%A4/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/23/ELK-%E5%AE%89%E8%A3%85es%E9%9B%86%E7%BE%A4/</id>
    <published>2020-11-23T11:30:18.000Z</published>
    <updated>2020-11-23T12:25:17.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：elasticsearch-7.3.2</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>假设三台主机</p><ul><li>centos0701 后续生命周期管理定位hot节点</li><li>centos0702 后续生命周期管理定位warm节点</li><li>centos0703 后续生命周期管理定位cold节点</li></ul><p>我们希望在每台主机上安装es实例，并且将三个es实例构成集群。</p><hr><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>这里使用docker方式安装。</p><p>修改三台主机hosts</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/hosts</span></span><br><span class="line"></span><br><span class="line"><span class="number">192.168</span><span class="number">.73</span><span class="number">.131</span>   <span class="string">centos0701</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.73</span><span class="number">.132</span>   <span class="string">centos0702</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.73</span><span class="number">.133</span>   <span class="string">centos0703</span></span><br></pre></td></tr></table></figure><p>docker安装需要拉取镜像或者已有的镜像导入scp分发镜像/安装包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp es-7.3.2.tar centos0701:/home/docker-images</span><br></pre></td></tr></table></figure><p>装载镜像/解压缩es</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load -i es-7.3.2.tar</span><br></pre></td></tr></table></figure><p> 三台机器ssh免密登录(非必须) </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id centos0701</span><br><span class="line">ssh-copy-id centos0702</span><br><span class="line">ssh-copy-id centos0703</span><br></pre></td></tr></table></figure><p>如果三台机器开启了防火墙，则需要开放防火墙端口，这里开启的是es使用的9200端口（http外部访问）和9300端口（集群间通信）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=9200/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=9300/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line">sudo firewall-cmd --zone=public --list-port</span><br></pre></td></tr></table></figure><p>修改es的配置文件，如果是docker方式，则需要将配置文件挂载。   </p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  vim es.yml</span></span><br><span class="line"><span class="comment">#集群名</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="comment">##本机节点名，根据不同的机器修改不同的名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">&quot;node-1&quot;</span></span><br><span class="line"><span class="comment">## 当前节点是否可以被选举为master节点，是：true、否：false</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">##集群生命周期节点配置hot/warm/cold</span></span><br><span class="line"><span class="comment">##这两项配置是为节点增加标签，具体名称并不是写死的，这个名称与后面模板和策略配置有关，后面会用到</span></span><br><span class="line"><span class="attr">node.attr.box_type:</span> <span class="string">hot</span></span><br><span class="line"><span class="attr">node.attr.rack:</span> <span class="string">rack1</span></span><br><span class="line"><span class="comment">##数据和日志存放位置，这里写的是docker内部的存放位置，后续可以挂载。</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/usr/share/elasticsearch/logs</span></span><br><span class="line"><span class="comment">## 主机访问的端口号和网关,docker安装方式下publish_host必须写成es容器宿主机的ip否则会解析成docker的内部ip导致无法建立集群。</span></span><br><span class="line"><span class="attr">network.bind_host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">network.publish_host:</span> <span class="number">192.168</span><span class="number">.73</span><span class="number">.131</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">##设置节点之间通信的端口</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment">## es7.x 之后新增的配置，写入候选主节点的设备地址，在开启服务后可以被选为主节点</span></span><br><span class="line"><span class="comment">## es7之后，不可使用旧版discovery.zen.ping.unicast.hosts这个参数，而用discovery.seed_hosts替换</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span>  [<span class="string">&quot;192.168.73.131&quot;</span>,<span class="string">&quot;192.168.73.132&quot;</span>,<span class="string">&quot;192.168.73.133&quot;</span>]</span><br><span class="line"><span class="comment">## 集群从节点中选举master</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;node-1&quot;</span>,<span class="string">&quot;node-2&quot;</span>,<span class="string">&quot;node-3&quot;</span>]</span><br></pre></td></tr></table></figure><p>三台机器启动docker或者运行es </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-v /home/moon/ELK/es/es.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /home/moon/ELK/es/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /home/moon/ELK/es/logs:/usr/share/elasticsearch/logs \</span><br><span class="line">--name es docker.elastic.co/elasticsearch/elasticsearch:7.3.2</span><br></pre></td></tr></table></figure><p>一台机器启动kibana，这里在<code>centos0701</code>主机上运行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name kibana -d -e &quot;ELASTICSEARCH_URL=http://192.168.73.131:9200&quot; -e &quot;SERVER_PORT=5601&quot;  -e &quot;SERVER_HOST=0.0.0.0&quot; -p 5601:5601 docker.elastic.co/kibana/kibana:7.3.2</span><br></pre></td></tr></table></figure><p>如果打开kibana网址显示<code>kibana server is not ready yet</code>，并且如果kibana日志显示<code>No living connections</code>的错误，则手动进入容器修改kibana.yml文件。如果是压缩包安装，则直接修改kibana.yml文件。具体修改server.host和elasticsearch.hosts。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [ <span class="string">&quot;http://192.168.73.131:9200&quot;</span> ]</span><br></pre></td></tr></table></figure><p>看到集群信息即说明集群搭建成功，游览器输入一下网址查询集群信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&#123;es的ip地址&#125;:9200&#x2F;_cat&#x2F;nodes?v</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：elasticsearch-7.3.2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;假设三台主机&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ELK" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/ELK/"/>
    
    
    <category term="ELK" scheme="https://shanjianyinxian.gitee.io/tags/ELK/"/>
    
    <category term="elasticsearch" scheme="https://shanjianyinxian.gitee.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>linux-centos7如何开启防火墙并且开放端口</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/18/linux-centos7%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99%E5%B9%B6%E4%B8%94%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/18/linux-centos7%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99%E5%B9%B6%E4%B8%94%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/</id>
    <published>2020-11-18T08:31:17.000Z</published>
    <updated>2021-07-10T09:43:41.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：centos7</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在对外开放服务的时候需要使用到端口，但是需要注意防火墙时候开放了自己所需的端口。在每次对外开放端口的时候需要先检查防火墙的情况。</p><hr><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用<code>systemctl</code>服务管理工具管理防火墙</p><ul><li><p>检查防火墙运行状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl status firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>启动防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>开机启动防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>开机禁用防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></li></ul><p>使用<code>firewalld-cmd</code> 操作防火墙</p><ul><li><p>开启一个端口（举例：8888端口）:</p><p>–zone=public 作用域<br>–permanent 永久生效，没有此参数重启后失效<br>–add-port=8888/tcp 打开8888端口，tcp协议</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --zone=public --add-port=8888/tcp --permanent </span><br></pre></td></tr></table></figure></li><li><p>查看所有打开的端口： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure></li><li><p>更新防火墙规则，此步骤在对防火墙端口规则修改后一定要执行，否则修改不生效： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>禁止一个已开放端口 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --zone=public --remove-port=8888/tcp --permanent </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：centos7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;在对外开放服务的时候需要使用到端口，但是需要注意防</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="linux" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/linux/"/>
    
    
    <category term="linux" scheme="https://shanjianyinxian.gitee.io/tags/linux/"/>
    
    <category term="centos" scheme="https://shanjianyinxian.gitee.io/tags/centos/"/>
    
    <category term="firewalld" scheme="https://shanjianyinxian.gitee.io/tags/firewalld/"/>
    
  </entry>
  
  <entry>
    <title>es生命周期管理（简单版）</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/16/es%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/16/es%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/</id>
    <published>2020-11-16T05:43:37.000Z</published>
    <updated>2020-11-19T06:52:34.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：ELK7.1.1</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>对于单节点进行生命周期管理，一般只是想自动删除过期数据。这里进行一个简单的配置。按照次模板进行修改即可。  </p><hr><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>设置索引生命周期管理一般步骤是：</p><ul><li>设定生命周期策略</li><li>设定索引模板</li><li>指定第一个索引</li></ul><p>在kibana的console工具中按照如下步骤进行：</p><ul><li><p>创建一个生命周期管理策略，只配置hot（必须）和delete（可选）。<br>–hot阶段，配置rollover策略，在文档数量大于10时进行。<br>–delete阶段，删除40s前的数据。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /_ilm/policy/nginx_ilm_policy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;policy&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;phases&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;hot&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;actions&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;rollover&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;max_docs&quot;</span>: <span class="string">&quot;10&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;delete&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;min_age&quot;</span>: <span class="string">&quot;40s&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;actions&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;delete&quot;</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>新建index模板，这一步目的是将送进es的符”index_patterns”的index按照新的规则进行滚动，并且绑定刚刚创建的生命周期规则。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /_template/nginx_ilm_template</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="attr">&quot;index_patterns&quot;</span>: [<span class="string">&quot;nginx_logs-*&quot;</span>],    </span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>: &#123;        </span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">1</span>,        </span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="number">1</span>,        </span><br><span class="line">        <span class="attr">&quot;index.lifecycle.name&quot;</span>: <span class="string">&quot;nginx_ilm_policy&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;index.lifecycle.rollover_alias&quot;</span>: <span class="string">&quot;nginx_logs&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>必须。这一步需要手动创建第一个滚动index，以滚动的alias开始（这里是nginx_logs）后续以数字结尾。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT nginx_logs-000001</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;aliases&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;nginx_logs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;is_write_index&quot;</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>非必须。生命周期策略默认10分钟执行一次，这里为了更快看到效果，改为10s执行。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attr">&quot;persistent&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;indices.lifecycle.poll_interval&quot;</span>:<span class="string">&quot;10s&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>重复插入demo数据多次，模拟多条日志入库效果，按照文档中的配置，这里需要提交10次以上才能看到滚动的效果 。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST nginx_logs/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;abbc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>最后查看rollover结果</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/indices/nginx_logs?v</span><br></pre></td></tr></table></figure><p>40s内<br><img src="/2020/11/16/es%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/rollover.jpg" alt="40s内的分段情况"></p><p>超过规定的时间后，就剩下了一个index<br><img src="/2020/11/16/es%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89/rollover2.jpg" alt="超过规定时间后的分段情况"></p></li></ul><p>至此我们完成了单节点的生命周期管理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：ELK7.1.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;对于单节点进行生命周期管理，一般只是想自动删除过</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ELK" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/ELK/"/>
    
    
    <category term="ELK" scheme="https://shanjianyinxian.gitee.io/tags/ELK/"/>
    
    <category term="elasticsearch" scheme="https://shanjianyinxian.gitee.io/tags/elasticsearch/"/>
    
    <category term="kibana" scheme="https://shanjianyinxian.gitee.io/tags/kibana/"/>
    
    <category term="生命周期管理" scheme="https://shanjianyinxian.gitee.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>0328. 奇偶链表</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/13/0328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/13/0328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</id>
    <published>2020-11-13T01:47:14.000Z</published>
    <updated>2020-11-13T01:54:10.556Z</updated>
    
    <content type="html"><![CDATA[<ul><li>链表</li><li>双指针</li><li>哑节点</li></ul><h4 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h4><p>这题双指针，配合哑节点，进行移动，将一个链表重新组装成两个链表，最后偶链表接在奇链表的后面。需要注意的是指针移动的条件，不满足<code>偶数节点为空或偶数节点下节点为空</code> 这种情况下才进行移动。<br><code>!(pOu == null || pOu.next == null)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode pJi = head;</span><br><span class="line">        ListNode pOu = head.next;</span><br><span class="line"></span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode dummy2 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode tail1 =dummy1;</span><br><span class="line">        ListNode tail2 = dummy2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            tail1.next = pJi;</span><br><span class="line">            tail2.next = pOu;</span><br><span class="line">            tail1 = tail1.next;</span><br><span class="line">            tail2 = tail2.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( !(pOu == <span class="keyword">null</span> || pOu.next == <span class="keyword">null</span>) )&#123;</span><br><span class="line">                pJi = pJi.next.next;</span><br><span class="line">                pOu = pOu.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail1.next = <span class="keyword">null</span>;</span><br><span class="line">            tail2.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail1.next = dummy2.next;</span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;双指针&lt;/li&gt;
&lt;li&gt;哑节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;328-奇偶链表&quot;&gt;&lt;a href=&quot;#328-奇偶链表&quot; class=&quot;headerlink&quot; title=&quot;328. 奇偶链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://shanjianyinxian.gitee.io/tags/leetcode/"/>
    
    <category term="双指针" scheme="https://shanjianyinxian.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="链表" scheme="https://shanjianyinxian.gitee.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="哑节点" scheme="https://shanjianyinxian.gitee.io/tags/%E5%93%91%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>0206. 反转链表</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/12/0206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/12/0206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-11-12T12:03:47.000Z</published>
    <updated>2020-11-12T12:18:57.346Z</updated>
    
    <content type="html"><![CDATA[<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h4><blockquote><p>链表哑节点的使用</p></blockquote><p>十分简单的题目，使用哑节点（dummy）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode newDummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        newDummy.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(dummy.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode p = dummy.next;</span><br><span class="line">            dummy.next = p.next;</span><br><span class="line">            p.next = newDummy.next;</span><br><span class="line">            newDummy.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newDummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;206-反转链表&quot;&gt;&lt;a href=&quot;#206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;206. 反转链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://shanjianyinxian.gitee.io/tags/leetcode/"/>
    
    <category term="链表" scheme="https://shanjianyinxian.gitee.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="哑节点" scheme="https://shanjianyinxian.gitee.io/tags/%E5%93%91%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>0865. 具有所有最深节点的最小子树</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/07/0865-%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/07/0865-%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91/</id>
    <published>2020-11-07T05:46:55.000Z</published>
    <updated>2020-11-12T12:19:22.024Z</updated>
    
    <content type="html"><![CDATA[<h4 id="865-具有所有最深节点的最小子树"><a href="#865-具有所有最深节点的最小子树" class="headerlink" title="865. 具有所有最深节点的最小子树"></a><a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/">865. 具有所有最深节点的最小子树</a></h4><blockquote><ul><li>树</li><li>层序遍历</li></ul></blockquote><p>首先按照层序遍历将树按照层拆分成不同的集合。首先判断最后一层，即叶子节点层是否只有一个节点，如果只有一个节点则直接返回叶子节点。然后从倒数第二行开始往根方向遍历，判断当前层的孩子节点是否在往叶子节点方向的下一层。将当前层更新为满足孩子节点在下一层的节点集合。如果当前层只有一个节点满足条件，则直接返回该节点。</p><p>整体的思路类似于不断合并节点。找到最小公共父节点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtreeWithAllDeepest</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        rowList = <span class="built_in">list</span>()</span><br><span class="line">        rowSet = <span class="built_in">set</span>()</span><br><span class="line">        rowSet.add(root)</span><br><span class="line">        rowList.append(rowSet)</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">            newRowSet = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> each <span class="keyword">in</span> rowSet:</span><br><span class="line">                <span class="keyword">if</span> each.left:</span><br><span class="line">                    newRowSet.add(each.left)</span><br><span class="line">                <span class="keyword">if</span> each.right:</span><br><span class="line">                    newRowSet.add(each.right)</span><br><span class="line">            <span class="keyword">if</span> newRowSet:</span><br><span class="line">                rowList.append(newRowSet)</span><br><span class="line">                rowSet = newRowSet</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(rowList) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        lastSet = rowList[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lastSet) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> lastSet.pop()</span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i, eachSet <span class="keyword">in</span> <span class="built_in">enumerate</span>(rowList[<span class="number">-2</span>::<span class="number">-1</span>]):</span><br><span class="line">            newLastSet = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> eachNode <span class="keyword">in</span> eachSet:</span><br><span class="line">                <span class="keyword">if</span> eachNode.left <span class="keyword">in</span> lastSet <span class="keyword">or</span> eachNode.right <span class="keyword">in</span> lastSet:</span><br><span class="line">                    newLastSet.add(eachNode)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(newLastSet) == <span class="number">1</span>:</span><br><span class="line">                ans = newLastSet.pop()</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lastSet = newLastSet</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;865-具有所有最深节点的最小子树&quot;&gt;&lt;a href=&quot;#865-具有所有最深节点的最小子树&quot; class=&quot;headerlink&quot; title=&quot;865. 具有所有最深节点的最小子树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://shanjianyinxian.gitee.io/tags/leetcode/"/>
    
    <category term="树" scheme="https://shanjianyinxian.gitee.io/tags/%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="https://shanjianyinxian.gitee.io/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>0116. 填充每个节点的下一个右侧节点指针</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/06/0116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/06/0116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</id>
    <published>2020-11-06T06:36:45.000Z</published>
    <updated>2020-11-06T06:40:22.277Z</updated>
    
    <content type="html"><![CDATA[<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><blockquote><ul><li>双指针</li><li>递归</li></ul></blockquote><p>本题使用层序遍历使用队列可以十分轻松的解决，由于题目中需要常数级别的空间复杂度，因此不使用该方法。按照本题题干中的提示，递归的调用栈所占空间不算空间复杂度。因此使用递归。</p><p>本题使用递归（前序遍历）方法解决：</p><ol><li><p>边界条件<br>如果根节点为null，则返回</p></li><li><p>递归过程<br>为根节点的两个孩子节点找到next</p><p><strong>左孩子节点找next</strong>：由于是完全二叉树，因此父节点一定包含左右两个孩子节点，root.left.next = root.right; 如果该节点为叶子节点则直接返回。</p><p><strong>右孩子节点找next</strong>：如果根节点root的next存在的话；则右孩子节点的next为root.next的左孩子节点。即root.right.next = root.next.left;</p><p>递归执行root.left和root.right</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        conn(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conn</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.right.next = root.next.left;</span><br><span class="line">        &#125;</span><br><span class="line">        conn(root.left);</span><br><span class="line">        conn(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;116-填充每个节点的下一个右侧节点指针&quot;&gt;&lt;a href=&quot;#116-填充每个节点的下一个右侧节点指针&quot; class=&quot;headerlink&quot; title=&quot;116. 填充每个节点的下一个右侧节点指针&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://shanjianyinxian.gitee.io/tags/leetcode/"/>
    
    <category term="双指针" scheme="https://shanjianyinxian.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="递归" scheme="https://shanjianyinxian.gitee.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>0057. 插入区间</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/06/0057-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/06/0057-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</id>
    <published>2020-11-06T06:25:05.000Z</published>
    <updated>2020-11-06T06:40:37.440Z</updated>
    
    <content type="html"><![CDATA[<h4 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/">57. 插入区间</a></h4><blockquote><p>大美兴，川普王！🤩</p><ul><li>朴素</li></ul></blockquote><p>这条hard题看完就知道咋做，一度怀疑自己是不是想的太简单了。直接看题解发现就是这么简单。。。</p><p>思路很简单，初始化合并区间的开始与结束为新插入区间newInterval的开始与结束，如果新插入区间的开始在某个已有区间内，则该已有区间的开始为合并区间的开始。如果新插入区间的结束在某个已有区间内，则该已有区间的结束为合并区间的结束，并将合并区间加入答案列表。</p><p>处理几个边界条件：</p><ul><li>如果新插入区间的结束不在某个已有区间内，则判断到newBack &lt; currPrev 时先将合并区间进入答案列表。</li><li>如果遍历完了还是没有插入合并区间，则在答案输出前将合并区间进入答案列表。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newPrev = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> newBack = newInterval[<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mixPrev = newPrev;</span><br><span class="line">        <span class="keyword">int</span> mixBack = newBack;</span><br><span class="line">        <span class="keyword">boolean</span> isInsert = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] i : intervals) &#123;</span><br><span class="line">            <span class="keyword">int</span> currPrev = i[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> currBack = i[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(currBack &lt; newPrev)&#123;</span><br><span class="line">                ansList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( currPrev &lt;= newPrev &amp;&amp; newPrev &lt;= currBack)&#123;</span><br><span class="line">                mixPrev = currPrev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( currPrev &lt;= newBack &amp;&amp; newBack &lt;= currBack)&#123;</span><br><span class="line">                mixBack = currBack;</span><br><span class="line">                ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mixPrev,mixBack&#125;);</span><br><span class="line">                isInsert = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(newBack &lt; currPrev )&#123;</span><br><span class="line">                <span class="keyword">if</span>(isInsert == <span class="keyword">false</span>)&#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mixPrev,mixBack&#125;);</span><br><span class="line">                    isInsert = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isInsert == <span class="keyword">false</span>)&#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mixPrev,mixBack&#125;);</span><br><span class="line">            isInsert = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> [][]ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;57-插入区间&quot;&gt;&lt;a href=&quot;#57-插入区间&quot; class=&quot;headerlink&quot; title=&quot;57. 插入区间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/insert-interval/&quot;&gt;57. </summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://shanjianyinxian.gitee.io/tags/leetcode/"/>
    
    <category term="朴素" scheme="https://shanjianyinxian.gitee.io/tags/%E6%9C%B4%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>0052. N皇后 II</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/06/0052-N%E7%9A%87%E5%90%8E%20II/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/06/0052-N%E7%9A%87%E5%90%8E%20II/</id>
    <published>2020-11-06T06:12:55.000Z</published>
    <updated>2020-11-06T06:41:18.243Z</updated>
    
    <content type="html"><![CDATA[<h4 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II</a></h4><blockquote><ul><li>N皇后</li><li>位运算</li><li>DFS</li></ul></blockquote><p>看的网上别人的思路自己复现出来的结果。充分运用位运算和深度优先搜索。用位运算表示当前位置能否放置棋子的情况，0表示未放置棋子，1表示不能放置棋子。</p><p>比如一个8位的棋盘，未放置任何棋子时第一行为00000000，若第四个位置放置了棋子。则变为00010000。第二行可以放置棋子的情况变成00111000。这是由于第一行的第四个位置放置了棋子，因此这个棋子的左下角第二行第三位，正下方第二行第四位和右下角第二行第五位都无法放置棋子。顺延下去，左下角的左下角：第三行第二位；正下方的正下方：第三行第四位；因此思路中使用了三个变量，left表示左斜下方的不可放置位，right表示右斜下方的不可放置位，col表示垂直列的不可放置位。</p><p>按照上文的例子第一行为00010000。则第二行left为00100000由上一行左移一位得到，col为00010000，right为00001000由上一行右移一位得到，因此第二行的可放置位情况为(left | right | col)，即00111000。left，right如同水纹散开分别进行左移右移。与此同时第二行插入新的棋子，即表示当前产生了新的“水纹”。因此newleft = (left | colbit) &lt;&lt; 1；newright = (right | colbit) &gt;&gt; 1;colbit表示插入的新的棋子位置。因此之后的“水纹”是新“水纹”和旧“水纹”的融合。列的情况比较简单。</p><p>使用深度优先搜索（dfs）进行整个运算过程。深度优先搜索的过程中，判断可插入位置是否还有空余位置可以插入，如果没能执行完最后一行就已经没有位置了，说明之前的插入方法不对。程序执行完自然返回并且无任何操作。如果已经执行完成了最后一行if(row &gt;= n)，则最终的结果+1并且直接返回。</p><p>注意：移位运算符的优先级低于加减乘除，因此需要注意在需要的地方加上括号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        currentLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//left表示左斜已被插入位置，right表示右斜已被插入位置，col表示垂直已被插入位置。0表示未被插入，1表示已插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">currentLine</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= n) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算当前的可插入情况。1为可插入 0为不可插入</span></span><br><span class="line">        <span class="keyword">int</span> current = ~(left | right | col) &amp; ((<span class="number">1</span>&lt;&lt;n) -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(current &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> colbit = current &amp; - current;</span><br><span class="line">            <span class="keyword">int</span> newleft = (left | colbit) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newright = (right | colbit) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newcol = col | colbit;</span><br><span class="line">            <span class="keyword">int</span> newrow = row + <span class="number">1</span>;</span><br><span class="line">            currentLine(newleft,newright,newrow,newcol,n);</span><br><span class="line">        </span><br><span class="line">            current = current &amp; (current - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;52-N皇后-II&quot;&gt;&lt;a href=&quot;#52-N皇后-II&quot; class=&quot;headerlink&quot; title=&quot;52. N皇后 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens-ii/&quot;&gt;52</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="N皇后" scheme="https://shanjianyinxian.gitee.io/tags/N%E7%9A%87%E5%90%8E/"/>
    
    <category term="位运算" scheme="https://shanjianyinxian.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="DFS" scheme="https://shanjianyinxian.gitee.io/tags/DFS/"/>
    
    <category term="leetcode" scheme="https://shanjianyinxian.gitee.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Kibana的Monitoring不进行数据的收集和监控</title>
    <link href="https://shanjianyinxian.gitee.io/2020/11/05/Kibana%E7%9A%84Monitoring%E4%B8%8D%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E7%9B%91%E6%8E%A7/"/>
    <id>https://shanjianyinxian.gitee.io/2020/11/05/Kibana%E7%9A%84Monitoring%E4%B8%8D%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E7%9B%91%E6%8E%A7/</id>
    <published>2020-11-05T02:42:55.000Z</published>
    <updated>2020-11-05T03:20:15.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件：ELK7.1.1</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Kibana的Monitoring不进行数据的收集和监控，配置正确的情况下无法找到监控的数据。出现了如下的问题：</p><p><img src="/2020/11/05/Kibana%E7%9A%84Monitoring%E4%B8%8D%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E7%9B%91%E6%8E%A7/1.jpg" alt="Kibana的Monitoring不进行数据的收集和监控"></p><hr><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>根据网上人的说法，有 ingest node 问题，还有配置文件不正确等。我这里提供一个新的思路。这是由于服务器与客户端的时间不同步造成的。<br><img src="/2020/11/05/Kibana%E7%9A%84Monitoring%E4%B8%8D%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E7%9B%91%E6%8E%A7/2.jpg" alt="由于服务器与客户端的时间不同步"></p><p>比如这里差了80分钟，将kibana监控界面的时间窗跨度扩大到80分钟以上时候即可得到数据。因此需要注意服务器的时间同步。</p><hr><h3 id="其他相关解决方案"><a href="#其他相关解决方案" class="headerlink" title="其他相关解决方案"></a>其他相关解决方案</h3><p><a href="https://elasticsearch.cn/question/7661">未打开 ingest node</a> </p><p><a href="https://github.com/elastic/kibana/issues/14398">GitHub讨论</a></p><p><a href="https://www.golinuxcloud.com/install-configure-metricbeat-monitor-cluster/#Error_Unable_to_find_the_cluster_in_the_selected_time_range_UUID">配置文件中监控数据收集时间过短</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件：ELK7.1.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;Kibana的Monitoring不进行数据的收</summary>
      
    
    
    
    <category term="技术" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ELK" scheme="https://shanjianyinxian.gitee.io/categories/%E6%8A%80%E6%9C%AF/ELK/"/>
    
    
    <category term="ELK" scheme="https://shanjianyinxian.gitee.io/tags/ELK/"/>
    
    <category term="kibana" scheme="https://shanjianyinxian.gitee.io/tags/kibana/"/>
    
  </entry>
  
</feed>
